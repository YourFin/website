---
title: Writing JSON APIs
order: 11
intro: >
  Lucky comes with helpers to make it easy process JSON params, write JSON
  responses, and respond with helpful errors.
---

## Respond with JSON

To respond with JSON we use the `json` method in an action:

```
# in src/actions/api/articles/show.cr
class Api::Articles::Show < ApiAction
  action do
    json {title: "My Post"}
    # Add an optional status code
    json {title: "My Post"}, Status::Ok # or use an integer like `200`
  end
end
```

> Here is a [list of all statuses Lucky
supports](https://github.com/luckyframework/lucky/blob/9e390e12c9f517517f6526d26fde372dfd02585c/src/lucky/action.cr#L20-L80)

### Create a serializer

> You may need to require the `src/json` folder if project was generated with
Lucky CLI 0.7 or earlier. You can do this by adding `require "./json/**`"
after `require "./pages/**"` in your `src/app.cr` file.

Serializers help you customize the response, and allow you to share common
JSON.

Let’s create one for rendering the JSON for a single article.

```
# in src/json/articles/show_json.cr
class Articles::ShowJSON < Lucky::Serializer
  def initialize(@article : Article)
  end

  def render
    {title: @article.title}
  end
end

# in the action
class Api::Articles::Show < ApiAction
  action do
    article = ArticleQuery.new.find(id)
    json Articles::ShowJSON.new(article)
  end
end
```

### Handling nested JSON and extra options

Here’s how you can combine JSON for more complex responses. In this example
we’ll render a list of articles and the total number of articles:

```
# in src/json/articles/index_json.cr
class Articles::IndexJSON
  def initialize(@articles : ArticleQuery, @total : Int64)
  end

  def render
    {
      # reuse the existing Articles::ShowJSON
      articles: @articles.map { |article| ShowJSON.new(article) },
      total: @total
    }
  end
end

# in src/actions/api/articles/index.cr
class Api::Articles::Index < ApiAction
  action do
    articles = ArticleQuery.new
    total = ArticleQuery.new.count
    json IndexJSON.new(articles, total)
  end
end
```

## Saving to the database

Forms automatically know how to handle JSON params. They just need to be
formatted in a way LuckyRecord knows how to handle.

Let’s say you have a form called `ArticleForm`. Lucky will look for the data
nested under an `article` key:

```json
{
  article: {
    title: "A new article"
  }
}
```

And then save it like you normally would:

```crystal
class Api::Articles::Create < ApiAction
  action do
    ArticleForm.create(params) do |form, article|
      if article
        json ShowJSON.new(article), Status::Created
      else
        head Status::UnprocessableEntity
      end
    end
  end
end
```

## Handling errors productively
The above example works, but it would be a pain to handle errors like this in every single action where we create something.

Instead we’ll create a method in `Errors::Show` for handling form errors:

```crystal
# in src/errors/show.cr
class Errors::Show < Lucky::ErrorAction
  def handle_error(error : LuckyRecord::InvalidFormError)
    if json?
      json {message: "Failed to save"}, Status::UnprocessableEntity
    end
  end
end
```

This works, but it’s more flexible to create a class for handling errors that can be reused:

```crystal
# in src/json/error_json.cr
class ErrorJSON < Lucky::Serializer
  def initialize(@message : String, @details : String)
  end

  def render
    {
      message: @message,
      details: @details
    }
  end
end
```

And use it:

```
# in src/actions/errors/show.cr
def handle_error(error : LuckyRecord::InvalidFormError)
  json ErrorJSON.new(title: "Failed to save", details: "there were errors on the field")
end
```

Now that invalid form errors are handled automatically, we can switch to
using `create!` in our action:

```crystal
class Api::Articles::Create < ApiAction
  action do
    # create! will raise if the params are invalid
    ArticleForm.create!(params) do |form, article|
      json ShowJSON.new(article), Status::Created
    end
  end
end
```

## Processing JSON that isn’t saved to the database

You can use `JSON.mapping` and `JSON.parse` to parse the response body in any
way you’d like.

## Sending empty responses

Sometimes you just need to return a status code. For that we use the `head` method:

```crystal
# inside an action
head Status::Created
# or use an integer
head 201
```
